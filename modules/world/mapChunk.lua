local love = require("love")
local GlobalConfig = require("global_config")
local Building = require("building")
local Utils = require("utils")
--[[
    A map chunk represents a section of the game world.
    Each chunk can contain buildings, streets, and other features.
    Chunks are generated by taking a starting X-coordinate and a type (e.g., "street", "building_zone").
    Using the "chunkWeight" from GlobalConfig, we can determine the type of chunk to generate.
    
    If the type is "building_zone", it will generate a building in the middle of the chunk.
    A "building_zone" chunk will be generated with a ground body for collisions.
    Also we'll add a Building object which will contain the building's physics body, shape, and fixture.
    The building will be positioned roughly in the middle of the chunk, standing on the ground.
    
    If the type is "street", it will generate a street with no buildings.
    a "street" chunk will be generated with a ground body for collisions.
    Also to generate the different quads for the street sprites we'll use a atlas which contains the street sprites.

--]]

local MapChunk = {}
MapChunk.__index = MapChunk

function MapChunk:new(world, startX, type)
    local instance = setmetatable({}, self)

    instance.world = world
    -- World X-coordinate where this chunk begins
    instance.startX = startX 
    instance.width = GlobalConfig.MAP.chunkWidth
    -- Y-coord of the top of the ground
    instance.groundY = GlobalConfig.MAP.groundY 
    instance.type = type or "street"

    instance.buildings = {}

    instance.chunkCanvas = love.graphics.newCanvas(self.width, love.graphics.getHeight())


    -- Physics: Create a static body for the ground within this chunk
    -- For a truly infinite ground plane, you might want one continuous ChainShape.
    -- But for chunk-based generation, this works:
    -- instance.groundBody = love.physics.newBody(self.world, instance.startX + instance.width / 2, instance.groundY + GlobalConfig.MAP.groundHeight / 2, "static")
    -- instance.groundShape = love.physics.newRectangleShape(instance.width, GlobalConfig.MAP.groundHeight)
    -- instance.groundFixture = love.physics.newFixture(instance.groundBody, instance.groundShape)
    -- instance.groundFixture:setFriction(1.0)
    -- instance.groundFixture:setUserData({type = "ground"}) -- Useful for collision callbacks (e.g., player landing)

    instance:generateContent()

    return instance
end

function MapChunk:generateContent()
    -- Basic example: Place a building if this is a 'building_zone'
    if self.type == "building_zone" then
        local buildingWidth = GlobalConfig.BUILDING.defaultWidth
        local buildingHeight = GlobalConfig.BUILDING.defaultHeight
        -- Position building roughly in the middle of the chunk, standing on the ground
        local buildingX = self.startX + self.width / 2
        local buildingY = self.groundY - buildingHeight / 2 -- Center Y for physics body

        local newBuilding = Building:new(
            self.world,
            buildingX,
            buildingY,
            "shop" -- Example building type (matches sprite in config)
        )
        table.insert(self.buildings, newBuilding)
    
    elseif self.type == "street" then
        -- Using  a random walk we generate different Y coordinates for the street height values
        -- each time based upon the previous Y coordinate.
        -- This will create a more dynamic street layout
        local currentY = self.groundY
        local currentX = 0

        local streetLight = false
        local quadNumberInSpriteAtlas = 0
        local choosenQuad = nil
        local streetAtlas = GlobalConfig.SPRITES.street.streetAtlas
        local quadList = {}
        for i = 1, #GlobalConfig.SPRITES.street.quads do 
            quadList[i] = love.graphics.newQuad(
                GlobalConfig.SPRITES.street.spriteWidth * (i - 1), GlobalConfig.SPRITES.street.spriteHeight, 
                GlobalConfig.SPRITES.street.spriteWidth, 
                GlobalConfig.SPRITES.street.spriteHeight, 
                streetAtlas.image:getWidth(), 
                streetAtlas.image:getHeight()
            )
        end


        -- Draw the street tile to the canvas
        love.graphics.setCanvas(self.chunkCanvas)
        love.graphics.clear() -- Clear the canvas before drawing
        for i = 0, self.width / 16 do
            -- Randomly choose a quad for the street sprite
            choosenQuad = Utils.Functions.randomWeighted(
                GlobalConfig.GAMEPLAY.MAP.chunkWeights.streetWeights,
                {
                    "streetLight",
                    "streetFlat",
                    "streetUp",
                    "streetDown",
                }
            )
            
            if choosenQuad == "streetLight" then
                currentY = currentY
                streetLight = true
                quadNumberInSpriteAtlas = 0
            elseif choosenQuad == "streetFlat" then
                currentY = currentY
                streetLight = false
                quadNumberInSpriteAtlas = 3
            elseif choosenQuad == "streetUp" then
                currentY = currentY + 16 -- Move street up
                streetLight = false
                quadNumberInSpriteAtlas = 1
            elseif choosenQuad == "streetDown" then
                currentY = currentY - 16 -- Move street down
                streetLight = false
                quadNumberInSpriteAtlas = 2
            end
            
            -- Draw the street tile
            love.graphics.draw(
                quadList[quadNumberInSpriteAtlas], self.startX + i * 16, currentY
            )
 
            if streetLight then 
                -- Draw street light if applicable
                local streetLightSprite = GlobalConfig.SPRITES.map.streetLight
                if streetLightSprite then
                    love.graphics.draw(streetLightSprite, self.startX + i * 16, currentY - 16) -- Adjust Y for light position
                end
            end
            
        end
    end
    
end

function MapChunk:update(dt)
    -- Update logic for dynamic elements within the chunk (e.g., destructible props)
    for _, building in ipairs(self.buildings) do
        building:update(dt) -- Buildings might have their own update logic (e.g., for damage)
    end
end

function MapChunk:draw(cameraX)
    -- Draw background layer (sky) - moves slowest
    -- You'll need to load these images in your main love.load or global_config
    local sky = GlobalConfig.SPRITES.map.backgroundSky
    if sky then
        love.graphics.draw(sky, -(cameraX * 0.05) % sky:getWidth(), 0) -- Adjust 0.05 for speed
        -- Draw a second one for tiling
        love.graphics.draw(sky, -(cameraX * 0.05) % sky:getWidth() + sky:getWidth(), 0)
    end

    -- Draw distant city background - moves a bit faster
    local city = GlobalConfig.SPRITES.map.backgroundCityDistant
    if city then
        love.graphics.draw(city, self.startX - cameraX * 0.3, GlobalConfig.MAP.groundY - city:getHeight() + 20) -- Adjust 0.3 for speed
    end

    -- Draw ground tiles
    local groundTile = GlobalConfig.SPRITES.map.groundTile
    if groundTile then
        local tileWidth = groundTile:getWidth()
        local numTiles = math.ceil(self.width / tileWidth)
        for i = 0, numTiles - 1 do
            love.graphics.draw(groundTile, self.startX + i * tileWidth, self.groundY,
                               0, tileWidth / tileWidth, GlobalConfig.MAP.groundHeight / groundTile:getHeight()) -- Scale to ground height
        end
    end

    -- Draw buildings
    for _, building in ipairs(self.buildings) do
        building:draw()
    end

    -- Debug draw ground physics body
    if GlobalConfig.DEBUG_MODE then
        love.graphics.setColor(0, 0.8, 0, 0.5) -- Green transparent
        local bodyX, bodyY = self.groundBody:getPosition()
        local shape = self.groundFixture:getShape()
        local vertices = {shape:getVertices()}
        local worldVertices = {}
        for i = 1, #vertices, 2 do
            local vx, vy = vertices[i], vertices[i+1]
            local wx, wy = self.groundBody:getWorldPoint(vx, vy)
            table.insert(worldVertices, wx)
            table.insert(worldVertices, wy)
        end
        love.graphics.polygon("line", worldVertices)
        love.graphics.setColor(1, 1, 1, 1)
    end
end

function MapChunk:destroy()
    if self.groundBody then
        self.groundBody:destroy()
        self.groundBody = nil
        self.groundFixture = nil
    end
    for _, building in ipairs(self.buildings) do
        building:destroy() -- Buildings need their own destroy method
    end
    self.buildings = {}
end

return MapChunk